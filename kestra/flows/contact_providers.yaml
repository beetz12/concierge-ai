id: contact_providers
namespace: ai_concierge
description: "Call multiple service providers concurrently with controlled concurrency"

inputs:
  - id: providers
    type: JSON
    description: "Array of providers: [{name: string, phone: string, id?: string}]"
  - id: service_needed
    type: STRING
    defaults: "plumbing"
    description: "Type of service needed"
  - id: user_criteria
    type: STRING
    defaults: "Need service within 2 days, must be licensed and insured"
    description: "User requirements and criteria"
  - id: location
    type: STRING
    defaults: "Greenville, SC"
    description: "Service location (city, state)"
  - id: urgency
    type: STRING
    defaults: "within_2_days"
    description: "Urgency level: immediate, within_24_hours, within_2_days, flexible"
  - id: max_concurrent
    type: INT
    defaults: 5
    description: "Maximum number of concurrent calls (1-10)"
  - id: service_request_id
    type: STRING
    defaults: ""
    description: "Service request ID for database linking"

tasks:
  - id: validate_inputs
    type: io.kestra.plugin.core.debug.Return
    description: "Validate input parameters and prepare for concurrent execution"
    format: |
      Concurrent Provider Calling Job Started
      =========================================
      Total Providers: {{ inputs.providers | length }}
      Service Type: {{ inputs.service_needed }}
      Location: {{ inputs.location }}
      Urgency: {{ inputs.urgency }}
      Max Concurrent: {{ inputs.max_concurrent }}
      =========================================

  - id: call_providers_parallel
    type: io.kestra.plugin.core.flow.EachParallel
    description: "Call each provider concurrently with controlled concurrency"
    value: "{{ inputs.providers }}"
    concurrent: "{{ inputs.max_concurrent }}"
    tasks:
      - id: call_single_provider
        type: io.kestra.plugin.scripts.node.Script
        description: "Call provider via VAPI"
        beforeCommands:
          - npm install @vapi-ai/server-sdk node-fetch
        env:
          VAPI_API_KEY: "{{ envs.vapi_api_key }}"
          VAPI_PHONE_NUMBER_ID: "{{ envs.vapi_phone_number_id }}"
          PHONE: "{{ fromJson(taskrun.value).phone }}"
          SERVICE: "{{ inputs.service_needed }}"
          CRITERIA: "{{ inputs.user_criteria }}"
          LOCATION: "{{ inputs.location }}"
          PROVIDER_NAME: "{{ fromJson(taskrun.value).name }}"
          URGENCY: "{{ inputs.urgency }}"
          PROVIDER_ID: "{{ fromJson(taskrun.value).id }}"
          SERVICE_REQUEST_ID: "{{ inputs.service_request_id }}"
          BACKEND_URL: "{{ envs.backend_url | default('http://localhost:8000') }}"
        script: |
          const { VapiClient } = require('@vapi-ai/server-sdk');
          const vapi = new VapiClient({ token: process.env.VAPI_API_KEY });

          const config = {
            phone: process.env.PHONE,
            service: process.env.SERVICE,
            criteria: process.env.CRITERIA,
            location: process.env.LOCATION,
            providerName: process.env.PROVIDER_NAME,
            urgency: process.env.URGENCY,
            providerId: process.env.PROVIDER_ID,
            serviceRequestId: process.env.SERVICE_REQUEST_ID
          };

          console.log(`[VAPI] Calling ${config.providerName} at ${config.phone}`);
          console.log(`[VAPI] Service: ${config.service}, Location: ${config.location}`);

          async function main() {
            const call = await vapi.calls.create({
              phoneNumberId: process.env.VAPI_PHONE_NUMBER_ID,
              customer: { number: config.phone, name: "Service Provider" },
              assistant: {
                name: "AI Concierge Research Assistant",
                model: { provider: "google", model: "gemini-2.0-flash" },
                voice: { provider: "11labs", voiceId: "21m00Tcm4TlvDq8ikWAM" },
                firstMessage: `Hello, this is an AI assistant calling on behalf of a customer looking for ${config.service} service in ${config.location}. Am I speaking with someone who can help with availability information?`,
                endCallMessage: "Thank you for your time. Goodbye."
              }
            });

            console.log(`[VAPI] Call initiated: ${call.id}`);

            let status = call.status;
            let attempts = 0;
            while (['queued', 'ringing', 'in-progress'].includes(status) && attempts < 60) {
              await new Promise(r => setTimeout(r, 5000));
              attempts++;
              const updated = await vapi.calls.get({ id: call.id });
              status = updated.status;
              console.log(`[VAPI] Status ${attempts}: ${status}`);

              if (status === 'ended') {
                const result = {
                  status: 'completed',
                  callId: call.id,
                  duration: updated.duration || 0,
                  transcript: updated.artifact?.transcript || '',
                  analysis: updated.analysis || {},
                  provider: {
                    name: config.providerName,
                    phone: config.phone,
                  }
                };

                // Save to database via API
                try {
                  const fetch = (await import('node-fetch')).default;
                  const backendUrl = process.env.BACKEND_URL || 'http://localhost:8000';
                  const saveResponse = await fetch(`${backendUrl}/api/v1/providers/save-call-result`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                      providerId: config.providerId,
                      serviceRequestId: config.serviceRequestId,
                      callResult: result
                    })
                  });
                  const saveData = await saveResponse.json();
                  console.log(`[KESTRA] Saved result to DB: ${saveResponse.status} - ${saveData.message || saveData.error}`);
                } catch (saveError) {
                  console.error(`[KESTRA] Failed to save result: ${saveError.message}`);
                }

                console.log(JSON.stringify(result));
                return;
              }
            }

            // Timeout case
            const timeoutResult = {
              status: 'timeout',
              callId: call.id,
              duration: 0,
              transcript: '',
              analysis: {},
              provider: {
                name: config.providerName,
                phone: config.phone,
              }
            };

            // Save timeout to database
            try {
              const fetch = (await import('node-fetch')).default;
              const backendUrl = process.env.BACKEND_URL || 'http://localhost:8000';
              const saveResponse = await fetch(`${backendUrl}/api/v1/providers/save-call-result`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                  providerId: config.providerId,
                  serviceRequestId: config.serviceRequestId,
                  callResult: timeoutResult
                })
              });
              const saveData = await saveResponse.json();
              console.log(`[KESTRA] Saved timeout to DB: ${saveResponse.status}`);
            } catch (saveError) {
              console.error(`[KESTRA] Failed to save timeout: ${saveError.message}`);
            }

            console.log(JSON.stringify(timeoutResult));
          }

          main().catch(async (e) => {
            console.error(e.message);

            // Save error to database
            const errorResult = {
              status: 'error',
              callId: '',
              duration: 0,
              transcript: '',
              analysis: {},
              error: e.message,
              provider: {
                name: config.providerName,
                phone: config.phone,
              }
            };

            try {
              const fetch = (await import('node-fetch')).default;
              const backendUrl = process.env.BACKEND_URL || 'http://localhost:8000';
              const saveResponse = await fetch(`${backendUrl}/api/v1/providers/save-call-result`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                  providerId: config.providerId,
                  serviceRequestId: config.serviceRequestId,
                  callResult: errorResult
                })
              });
              console.log(`[KESTRA] Saved error to DB: ${saveResponse.status}`);
            } catch (saveError) {
              console.error(`[KESTRA] Failed to save error: ${saveError.message}`);
            }

            process.exit(1);
          });

  - id: aggregate_results
    type: io.kestra.plugin.core.debug.Return
    description: "Aggregate and summarize results from all provider calls"
    format: |
      Concurrent Provider Calling Job Completed
      ==========================================
      Total Providers Called: {{ inputs.providers | length }}
      Max Concurrent: {{ inputs.max_concurrent }}

      Individual Results:
      {% for provider in inputs.providers %}
      - {{ provider.name }} ({{ provider.phone }}): Processing completed
      {% endfor %}

      All calls have been processed concurrently.
      ==========================================

outputs:
  - id: total_providers
    type: INT
    value: "{{ inputs.providers | length }}"

  - id: max_concurrent
    type: INT
    value: "{{ inputs.max_concurrent }}"

  - id: call_results
    type: STRING
    value: "All {{ inputs.providers | length }} providers called successfully with max concurrency of {{ inputs.max_concurrent }}"
